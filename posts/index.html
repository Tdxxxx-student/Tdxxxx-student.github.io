<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 我的博客</title><meta name=keywords content><meta name=description content="Posts - 我的博客"><meta name=author content><link rel=canonical href=https://Tdxxxx-student.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://Tdxxxx-student.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Tdxxxx-student.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://Tdxxxx-student.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://Tdxxxx-student.github.io/apple-touch-icon.png><link rel=mask-icon href=https://Tdxxxx-student.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://Tdxxxx-student.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://Tdxxxx-student.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://Tdxxxx-student.github.io/posts/"><meta property="og:site_name" content="我的博客"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://Tdxxxx-student.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://Tdxxxx-student.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Tdxxxx-student.github.io/posts title=个人><span class=active>个人</span></a></li><li><a href=https://Tdxxxx-student.github.io/docs title=教程><span>教程</span></a></li><li><a href=https://Tdxxxx-student.github.io/study title=学习><span>学习</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>基因家族分析</h2></header><div class=entry-content><p>基因家族分析流程与文章撰写思路 基因家族分析是一种常见的生物信息学分析套路，也是生物信息学数据挖掘发表小文章常用的分析方法，和GEO挖掘等类似。基因家族的分析鉴定可以用pfam上的hmm文件进行基因家族的检索鉴定，也可以用blast的方法进行比对鉴定，通常是适用拟南芥对应的基因家族进行比对鉴定。
植物转录因子数据库，点击访问。
基因家族分析思路及文章撰写思路 基因家族分析是继GEO数据挖掘后，一种新的生物信息学挖掘策略。
如何做基因家族研究，可以参考这个帖子：http://www.planttech.com.cn/blog/58882464a46。
数据准备 需要准备的数据主要是参考基因组数据，包括fasta格式的序列文件、gff或gtf格式的基因组注释文件、蛋白质序列文件（通常是每个转录本的蛋白序列）、cDNA序列等文件。如果有转录组数据的话进行对应的转录组分析即可。除开上述这些文件外，还需要适用的文件还有.hmm格式的文件。
软件准备 只需要会使用Linux系统，会安装Docker即可，然后下载组学大讲堂的镜像即可。点击浏览镜像地址。Docker的安装适用方法参考@ref(WSL4Docker)。
分析过程 mRNA_ID与基因ID的提取 由于一个基因会对应多个转录本，因此一个基因下会对应多个mRNA的编号。在后续的分析中，每个基因只需要选择一个转录本的编号进行分析即可，因为每个基因不同的转录本的序列差异是较小的。提取的代码：
bash perl code/script/mRNAid_to_geneid.pl data/unzip_data/.gff results/step.1.get.mRNA.and.gene.ID/mRNA2geneID.txt perl code/script/geneid_to_mRNAid.pl data/unzip_data/.gff results/step.1.get.mRNA.and.gene.ID/geneID2mRNAid.txt 检索结构域 这一步主要是以.hmm文件为基础检索该物种蛋白序列中含有该结构域的序列。输入文件包括.hmm文件和蛋白文件，输出hmmsearch的检索结果。其中用于后续筛选的是evalue这个参数，部分文章以0.001为阈值。of那一列表示的是某个基因对应的这个结构域有几个。
bash hmmsearch –domtblout results/step.2.domain.search/hmm.txt –cut_tc data/unzip_data/.hmm data/unzip_data/.pep* 选择结构域 由于一个基因的单个转录本可能会比对到多个结构域，因此需要对比对到的结构域进行选择。默认选择的是第一个结构域。下面代码的最后一个参数是hmmsearch输出文件里面的E-value,如果需要全部的第一个结构域，将阈值设置为1即可。
bash perl code/script/domain_xulie.pl results/step.2.domain.search/hmm.txt data/unzip_data/.pep results/step.2.domain.search/domain.fa 1.2e-28 多序列比对 之所以要进行多序列比对，是因为下载的.hmm文件是来自很多物种的这个结构域组成的隐马尔科夫模型，进行多序列比对后将该物种检索到的结构域序列进行比对，再次构建该物种该基因家族的隐马尔科夫模型，会更加准确。
bash echo -e ‘1\nresults/step.2.domain.search/domain.fa\n2\n1\nresults/step.2.domain.search/out.aln\nr.domain.search/out.dnd\nX\n\n\nX\n’ |clustalw 重构隐马尔科夫模型 bash hmmbuild results/step.2.domain.search/new.hmm results/step.2.domain.search/out.aln 重新进行检索 利用构建得到的新的隐马尔科夫模型重新进行检索结构域。
bash hmmsearch –domtblout results/step.2.domain.search/new.out.txt –cut_tc results/step.2.domain.search/new.hmm data/unzip_data/.pep 筛选输出结果 对重新检索后的结果进行筛选，也是对E-value进行筛选。
bash grep -v “^#” results/step.2.domain.search/new.out.txt|awk ‘$7&lt;0.001 {print}’ > results/step.2.domain.search/domain.new.out.selected.txt 去除重复的ID 上一步筛选得到的是该种中哪些基因是潜在的目标基因家族成员，而一个基因对应了多个mRNA，因此，只需要在筛选后的每个基因中选择一个具有代表性的mRNA进行后续的分析即可。这个提取唯一ID的步骤需要手动完成（PS：手动完成也很快）。手动挑选完mRNA的ID放在第一列，另存为文件uniqueID.txt。
...</p></div><footer class=entry-footer><span title='2026-02-03 16:53:01 +0800 +0800'>February 3, 2026</span></footer><a class=entry-link aria-label="post link to 基因家族分析" href=https://Tdxxxx-student.github.io/posts/%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F%E5%88%86%E6%9E%90/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>群体遗传学与重测序分析解释</h2></header><div class=entry-content><p>分子层面对生物的研究，在个体水平上主要是看单个基因的变化以及全转录本的变化（RNA-seq）；在对个体的研究的基础上，开始了群体水平的研究。如果说常规的遗传学主要的研究对象是个体或者个体家系的话，那么群体遗传学则是主要研究由不同个体组成的群体的遗传规律。 在测序技术大力发展之前，对群体主要是依靠表型进行研究，如加拉巴哥群岛的13中鸟雀有着不同的喙，达尔文认为这是自然选择造成的后果1。达尔文的进化论对应的观点可以简单概括为“物竞天择，适者生存”，这也是最为大众所接受的一种进化学说。直到1968年，日本遗传学家提出了中性进化理论[2]，也叫中性演化理论。中性理论的提出很大程度上是基于分子生物化学的发展。可以这样理解中性理论：一群人抽奖，在没有内幕的情况下，每个人抽到一等奖的概率是相等的，这个可能性和参与抽奖的人的身高、年龄、爱好等因素都没有关系。中性理论常作为群体遗传研究中的假设理论（CK）来计算其他各种统计指标。 群体遗传学，研究的单位是群体，比如粳稻、籼稻、野生稻，就能够构成不同的群体；我们国内的各省份的水稻也可以作为一个个群体。 群体遗传学大概可以分为群体内的研究和群体间的研究。比如研究云南元阳的水稻的遗传多样性；如果研究是的云南元阳的水稻和东北的水稻，那就可以算成是群体间的研究。群体间和群体内的研究是相互的。 测序价格的急剧下降[3]使得大规模的群体测序得以实现。
几种变异类型 常见的变异类型有SNP、IdDel、SV、CNV等。重测序中最关注的是SNP，其次是InDel。其他的几种结构变异的研究不是太多。
重测序和从头组装 有参考基因组的物种的全基因组测序叫做重测序，没有参考基因组的物种的全基因组测序则需要从头组装。随着测序价格的降低，越来越多物种的参考基因组都已经测序组装完成。plant genomes$^{[4]}$网站实时显示全基因组测序已经完成的植物，其中2012年以后爆发式增长。在群体遗传学研究中更多的是有参考基因组的物种，尤其是模式物种，植物中常见的是拟南芥、水稻和玉米。
重测序分析流程 主要的分析流程见下图。现在的测序公司基本上都会帮客户完成整个的分析流程，因为主要耗费的资源是计算资源。我认为在整个分析的流程中最重要的是Linux目录的构建，混乱的目录会导致后续的分析频频出问题，重测序分析会生成很多的中间文件，良好的目录管理会使得项目分析流程井然有序。 该部分涉及到的软件的安装和基础的Linux基础知识就不详细说明了。
群体进化选择 正选择 正选择似乎可以更好地用自然选择来解释。就是一个基因or位点能够使个体有着更强的生存力或者是育性，这样就会使得这个个体的后代更多，如此一来，这个基因or位点在群体中就越来越多。
正选择能够使有利的突变基因or位点在群体中得到传播，但是与此同时却降低了群体的多态性水平。也就是说原先该位点周围的核苷酸组成是多样性的，在经过正选择之后，这个位点周围核苷酸的多样性就渐渐的趋于同质化了。这就好比一块田，里面本来有水稻和稗草及其他杂草，由于稗草的适应性增强，稗草在逐渐增多，水稻慢慢变少，最后甚至是只剩下了稗草。 我们将这种选择之后多态性降低的情况叫做选择扫荡（Selective Sweep)。检测选择扫荡的软件有SweeD$^{[7]}$。选择扫荡有可能是人工选择的结果，如2014年 Nature Genetics关于非洲栽培稻的文章就使用了SweeD来检测非洲栽培稻基因组上受人工选择的区域$^{[8]}$。
负选择 负选择和正选择刚好是相反的。简单理解成群体中的某个个体出现了一个致命的突变，从而自己或者是后代从群体中被淘汰。这也导致群体中该位点的多态性的降低。就好比我有10株水稻，其中一株在成长过程中突然不见了，那么对我的这个小的水稻群体来说，这个消失的水稻的独有的位点在群体中就不见了，整体的多态性就降低了。
平衡选择 平衡选择指多个等位基因在一个群体的基因库中以高于遗传漂变预期的频率被保留，如杂合子优势。
平衡选择检测的算法有BetaScan2$^{[10]}$，这是个Python脚本，输入文件只需要过滤好的SNP数据即可。
群体遗传学中的统计指标 群体多态性参数 计算公式为：
其中$N_e$是有效群体大小，$\mu$是每个位点的突变速率。但是群体大小往往是无法精确知道的，需要对其进行估计。
分离位点数目 分离位点数$\theta_w$是$\theta$的估计值，表示相关基因在多序列比对中表现出多态性的位置。计算公式为：
其中$K$为分离位点数量，比如SNP数量。 $a_n$为个体数量的倒数和：
核苷酸多样性$\pi$ $\pi$指的是核苷酸多样性，值越大说明核苷酸多样性越高。通常用于衡量群体内的核苷酸多样性，也可以用来推演进化关系$^{[11]}$。计算公式为：
可以理解成现在群体内两两求$\pi$，再计算群体的均值。计算的软件最常见的是vcftools，也有对应的R包PopGenome。通常是选定有一定的基因组区域，设定好窗口大小，然后滑动窗口进行计算。 3KRGP文章就计算了水稻不同亚群间4号染色体部分区域上的$\pi$值$^{[12]}$，能够看出控制水稻籽粒落粒性的基因Sh4$^{[13]}$位置多态性在所有的亚群中都降低了。说明这个基因在所有的亚群中都是受到选择的，这可能是人工选择的结果。
群体内选择检验：Tajima’s D Tajima’s D是日本学者Tajima Fumio 1989年提出的一种统计检验方法，用于检验DNA序列在演化过程中是否遵循中性演化模型$^{[14]}$。计算公式为：
D值大小有如下三种生物学意义：
群体间分歧度检验：$F_{st}$ $F_{st}$叫固定分化指数，用于估计亚群间平均多态性大小与整个种群平均多态性大小的差异，反映的是群体结构的变化。其简单估计的计算公式为：
$F*{st}$的取值范围是[0,1]。当$F*{st}=1$时，表明亚群间有着明显的种群分化。 在中性进化条件下，$F*{st}$的大小主要取决于遗传漂变和迁移等因素的影响。假设种群中的某个等位基因因为对特定的生境的适应度较高而经历适应性选择，那该基因的频率在种群中会升高，种群的分化水平增大，使得种群有着较高的$F*{st}$值。 $F*{st}$值可以和GWAS的结果一起进行分析，$F*{st}$超过一定阈值的区域往往和GWAS筛选到的位点是一致的，如2018年棉花重测序的文章$^{[15]}$：
群体分歧度检验：ROD ROD可以基于野生群体和驯化群体间核苷酸多态性参数$\pi$的差异识别选择型号，也可以测量驯化群体和野生型群体相比损失的多态性。计算公式为：
和$F_{st}$一样，ROD也可以和GWAS结合起来：
群体结构分析 群体结构分析可以简单理解成采样测序的这些个体可以分成几个小组，以及给每个个体之间的远近关系是怎么样的。群体结构分析三剑客， 分别是进化树、PCA和群体结构图。
进化树 进化树就是将个体按照远近关系分别连接起来的图。
进化树算法 基于距离 非加权算术平均对群法UPGMA 邻接法Neighbor-joining 基于特征 最大简约法—最小变化数（祖先状态最小化） 最大似然法—所有枝长和模型参数最优化 贝叶斯推断—基于后验概率 进化树类型 有根树 有根树就是所有的个体都有一个共同的祖先。就像这样的： 无根树 无根树只展示个体间的距离，无共同祖先，就像这样的： 进化树软件 常用的绘图软件是Phylip和Snpphylo。进化树修饰的软件有MEGA，ggtree等，推荐网页版工具iTOL，无比强大。 外群定根法：当群体的个体的差异很小时，可以引入其他物种作为根。如在对三叶草建树时可以引入水稻的序列作为根进行建树。
...</p></div><footer class=entry-footer><span title='2026-02-03 12:17:02 +0800 +0800'>February 3, 2026</span></footer><a class=entry-link aria-label="post link to 群体遗传学与重测序分析解释" href=https://Tdxxxx-student.github.io/posts/%E7%BE%A4%E4%BD%93%E9%81%97%E4%BC%A0%E5%AD%A6%E4%B8%8E%E9%87%8D%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90%E8%A7%A3%E9%87%8A/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>云南农业大学重测序项目教程</h2></header><div class=entry-content><p>云南农业大学 云南生物资源保护与利用国家重点实验室
李详 | 2019 年 12 月 31 日
目录 软件安装 变异检测 群体结构分析 选择分析 GWAS 分析 QTL-seq 分析 附录：分析流程图 软件安装 ⚠️ 注意：该部分软件很难用 conda 直接安装，安装步骤比较特殊。
1. lumpy-sv 💡 lumpy-sv 依赖 Python2.7，需切换到 py27 环境下进行安装。
conda activate py27 git clone --recursive https://github.com/arq5x/lumpy-sv.git cd lumpy-sv make 2. svtyper conda install svtyper 3. cnvnator 💡 cnvnator 依赖于 root 软件包及 samtools 软件包（包含 HTSlib），因此先安装依赖。
3.1 安装 samtools wget https://github.com/samtools/samtools/releases/download/1.9/samtools-1.9.tar.bz2 tar -xvf samtools-1.9.tar.bz2 cd samtools-1.9/ ./configure make 3.2 安装 root 软件 # 直接下载后解压即可 wget https://root.cern/download/root_v6.18.04.Linux-ubuntu18-x86_64-gcc7.4.tar.gz tar -zxvf root_v6.18.04.Linux-ubuntu18-x86_64-gcc7.4.tar.gz 3.3 安装 cnvnator git clone https://github.com/abyzovlab/CNVnator.git cd CNVnator # 链接samtools软件目录到cnvnator目录 ln -s ../samtools-1.9 ./samtools # 加载root软件到环境变量 export ROOTSYS=/pub/software/root export PATH=/pub/software/root/bin:$PATH export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib # 安装cnvnator make LIBS="-lcrypto" 变异检测 1. 构建基因组 index # 创建软链接 ln -s ../data/genome.fasta ./genome.fasta # for gatk samtools faidx genome.fasta # for bwa bwa index genome.fasta # for picard picard CreateSequenceDictionary R=genome.fasta 2. 比对排序去重 2.1 比对排序 bwa mem -t 2 -R '@RG\tID:S1\tSM:S1\tPL:illumina' \ ../01.ref/genome.fasta \ ../data/S1_1.fq.gz ../data/S1_2.fq.gz | \ /pub/software/samtools/samtools sort -@ 2 -m 1G -o S1.sort.bam - bwa mem -t 2 -R '@RG\tID:S2\tSM:S2\tPL:illumina' \ ../01.ref/genome.fasta \ ../data/S2_1.fq.gz ../data/S2_2.fq.gz | \ /pub/software/samtools/samtools sort -@ 2 -m 1G -o S2.sort.bam - 2.2 去除重复 picard -Xmx4g MarkDuplicates \ I=S1.sort.bam \ O=S1.sort.rmdup.bam \ CREATE_INDEX=true \ REMOVE_DUPLICATES=true \ M=S1.marked_dup_metrics.txt picard -Xmx4g MarkDuplicates \ I=S2.sort.bam \ O=S2.sort.rmdup.bam \ CREATE_INDEX=true \ REMOVE_DUPLICATES=true \ M=S2.marked_dup_metrics.txt 2.3 比对率统计 /pub/software/samtools/samtools flagstat S1.sort.bam > S1.sort.bam.flagstat /pub/software/samtools/samtools flagstat S2.sort.bam > S2.sort.bam.flagstat 2.4 批量比对脚本生成 less ../data/sample.list | awk '{ print "bwa mem -t 2 -R '\''@RG\\tID:"$1"\\tSM:"$1"\\tPL:illumina'\'' \ ../01.ref/genome.fasta ../data/"$1"_1.fq.gz ../data/"$1"_2.fq.gz | \ /pub/software/samtools/samtools sort -@ 2 -m 1G -o "$1".sort.bam -" }' 3. SNP、Indel 检测 3.1 HaplotypeCaller gatk --java-options "-Xmx10g -Djava.io.tmpdir=./tmp" HaplotypeCaller \ -R ../01.ref/genome.fasta \ -I ../02.mapping/S1.sort.rmdup.bam \ -ERC GVCF \ -O S1.g.vcf 1>S1.HC.log 2>&amp;1 gatk --java-options "-Xmx10g -Djava.io.tmpdir=./tmp" HaplotypeCaller \ -R ../01.ref/genome.fasta \ -I ../02.mapping/S2.sort.rmdup.bam \ -ERC GVCF \ -O S2.g.vcf 1>S2.HC.log 2>&amp;1 3.2 CombineGVCFs ls ./S*.g.vcf > gvcf.list gatk --java-options "-Xmx4g -Djava.io.tmpdir=./tmp" CombineGVCFs \ -R ../01.ref/genome.fasta \ -V gvcf.list \ -O all.merge.g.vcf 3.3GenotpeGVCFs gatk --java-options "-Xmx4g -Djava.io.tmpdir=./tmp" GenotypeGVCFs \ -R ../01.ref/genome.fasta \ --variant all.merge.g.vcf \ -O all.merge_raw.vcf 3.4 SNP 过滤 # 提取SNP gatk --java-options "-Xmx4g -Djava.io.tmpdir=./tmp" SelectVariants \ -R ../01.ref/genome.fasta \ -V all.merge_raw.vcf \ --select-type SNP \ -O all.raw.snp.vcf # 标记过滤 gatk --java-options "-Xmx4g -Djava.io.tmpdir=./tmp" VariantFiltration \ -R ../01.ref/genome.fasta \ -V all.raw.snp.vcf \ --filter-expression "QD &lt; 2.0 || MQ &lt; 40.0 || FS > 60.0 || SOR > 3.0 || MQRankSum &lt; -12.5 || ReadPosRankSum &lt; -8.0" \ --filter-name 'SNP_filter' \ -O all.filter.snp.vcf # 提取过滤后的SNP gatk --java-options "-Xmx4g -Djava.io.tmpdir=./tmp" SelectVariants \ -R ../01.ref/genome.fasta \ -V all.filter.snp.vcf \ --exclude-filtered \ -O all.filtered.snp.vcf 3.5 InDel 过滤 # 提取InDel gatk --java-options "-Xmx4g -Djava.io.tmpdir=./tmp" SelectVariants \ -R ../01.ref/genome.fasta \ -V all.merge_raw.vcf \ --select-type INDEL \ -O all.raw.indel.vcf # 标记过滤 gatk --java-options "-Xmx4g -Djava.io.tmpdir=./tmp" VariantFiltration \ -R ../01.ref/genome.fasta \ -V all.raw.indel.vcf \ --filter-expression "QD &lt; 2.0 || FS > 200.0 || SOR > 10.0 || MQRankSum &lt; -12.5 || ReadPosRankSum &lt; -8.0" \ --filter-name 'INDEL_filter' \ -O all.filter.indel.vcf # 提取过滤后的InDel gatk --java-options "-Xmx4g -Djava.io.tmpdir=./tmp" SelectVariants \ -R ../01.ref/genome.fasta \ -V all.filter.indel.vcf \ --exclude-filtered \ -O all.filtered.indel.vcf 4. SV 检测 # Step 1: 提取 discordants reads /pub/software/samtools/samtools view -b -F 1294 -@ 12 \ ../02.mapping/S1.sort.rmdup.bam > S1.discordants.bam /pub/software/samtools/samtools view -b -F 1294 -@ 12 \ ../02.mapping/S2.sort.rmdup.bam > S2.discordants.bam # Step 2: 提取 split reads /pub/software/samtools/samtools view -h ../02.mapping/S1.sort.rmdup.bam | \ /pub/software/lumpy-sv/scripts/extractSplitReads_BwaMem -i stdin | \ /pub/software/samtools/samtools sort - > S1.splitters.bam /pub/software/samtools/samtools view -h ../02.mapping/S2.sort.rmdup.bam | \ /pub/software/lumpy-sv/scripts/extractSplitReads_BwaMem -i stdin | \ /pub/software/samtools/samtools sort - > S2.splitters.bam # Step 3: 运行 lumpy /pub/software/lumpy-sv/bin/lumpyexpress \ -B ../02.mapping/S1.sort.rmdup.bam,../02.mapping/S2.sort.rmdup.bam \ -S S1.splitters.bam,S2.splitters.bam \ -D S1.discordants.bam,S2.discordants.bam \ -o all.sv.lumpy.vcf # Step 4: 个体基因型分型 vcftools --vcf all.sv.lumpy.vcf --indv S1 --recode --recode-INFO-all --out S1 && \ svtyper -i S1.recode.vcf -B ../02.mapping/S1.sort.rmdup.bam -o S1.genotype.vcf vcftools --vcf all.sv.lumpy.vcf --indv S2 --recode --recode-INFO-all --out S2 && \ svtyper -i S2.recode.vcf -B ../02.mapping/S2.sort.rmdup.bam -o S2.genotype.vcf 5. CNV 检测 5.1 准备基因组 # 将基因组拆分为单条染色体 ln -s ../data/genome.fasta ./genome.fa seqkit split -i ./genome.fa -O split # 重命名文件 ls ./split/genome.id_*.fa | sed 's/./split/genome.id_//' | \ awk '{print "mv ./split/genome.id_"$aa" ./split/"$aa}' > mv_name.sh sh mv_name.sh 5.2 运行 cnvnator # 设置环境变量 export ROOTSYS=/pub/software/root export PATH=/pub/software/root/bin:$PATH export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib # 链接文件 ln -s ../02.mapping/S1.sort.rmdup.bam # 提取比对结果 /pub/software/CNVnator/cnvnator -genome genome.fa -root S1.root -tree S1.sort.rmdup.bam # 生成深度分布 /pub/software/CNVnator/cnvnator -genome genome.fa -root S1.root -his 500 -d split # 进行统计计算 /pub/software/CNVnator/cnvnator -root S1.root -stat 500 # 检查bin size是否合适 /pub/software/CNVnator/cnvnator -root S1.root -eval 500 > S1.eval.ratio # RD信号分割 /pub/software/CNVnator/cnvnator -root S1.root -partition 500 # 进行CNV检测 /pub/software/CNVnator/cnvnator -root S1.root -call 500 > S1.cnv 6. SNP/InDel 注释 6.1 准备注释数据库 ln -s ../data/genome.gtf ln -s ../data/genome.fasta gtfToGenePred -genePredExt genome.gtf genome_refGene.txt /pub/software/annovar/retrieve_seq_from_fasta.pl \ --format refGene \ --seqfile genome.fasta \ genome_refGene.txt \ --out genome_refGeneMrna.fa 6.2 注释 VCF 文件 ln -s ../03.SNP_indel/all.filtered.snp.vcf # 格式转换 /pub/software/annovar/convert2annovar.pl \ -format vcf4old \ all.filtered.snp.vcf > all.snp.vcf.annovar.input # 进行注释 /pub/software/annovar/annotate_variation.pl \ -geneanno \ --neargene 2000 \ -buildver genome \ -dbtype refGene \ -outfile all.anno \ -exonsort \ all.snp.vcf.annovar.input ./ 7. CNV 和 SV 注释 # 处理SV文件 less -S ../04.SV/all.sv.lumpy.vcf | \ awk -F ";" '{ if($1!~/#/){print $1"\t"$2"\t"$3"\t"$4} }' | \ awk '{print $1"\t"$2"\t"$11"\t"$3"\t"$8}' | \ sed 's/END=//' | sed 's/SVTYPE=//' > SV.bed # 过滤BND类型 awk '$5 !~ /BND/' SV.bed > SV_filter.bed # SV注释 bedtools intersect -wo -a SV_filter.bed -b gene.gtf > SV_filter.Anno # 处理CNV文件 less -S ../05.CNV/S1.cnv | \ awk '{print $2 "\t" $1}' | \ sed 's/:/\t/' | sed 's/-/\t/' > CNV.bed # CNV注释 bedtools intersect -wo -a CNV.bed -b gene.gtf > CNV.Anno 群体结构分析 1. 数据过滤 vcf=../data/all.vcf # 过滤缺失率和最小等位基因频率 plink --vcf $vcf \ --geno 0.1 \ --maf 0.01 \ --out all.missing_maf \ --recode vcf-iid \ --allow-extra-chr \ --set-missing-var-ids @:# \ --keep-allele-order # 过滤连锁不平衡 plink --vcf all.missing_maf.vcf \ --indep-pairwise 50 10 0.2 \ --out tmp.ld \ --allow-extra-chr \ --set-missing-var-ids @:# plink --vcf all.missing_maf.vcf \ --make-bed \ --extract tmp.ld.prune.in \ --out all.LDfilter \ --recode vcf-iid \ --keep-allele-order \ --allow-extra-chr \ --set-missing-var-ids @:# 2. 建树分析 2.1 NJ 树 # 格式转换 perl ../../script/vcf2phy.pl ../../00.filter/all.LDfilter.vcf > sequences.dat # 计算遗传距离 echo -e "sequences.dat\nY" > dnadist.cfg dnadist &lt; dnadist.cfg > dnadist.log mv outfile infile.dist # 构建NJ树 echo -e "infile.dist\nY" > neighbor.cfg neighbor &lt; neighbor.cfg > nj.log # 格式整理 less infile.dist | tr '\n' '|' | sed 's/| / /g' | tr '|' '\n' > infile.dist.table less outtree | tr '\n' ' ' | sed 's/ //g' > outtree.nwk 2.2 SNPhylo 建树 /pub/software/SNPhylo/snphylo.sh \ -v ../../00.filter/all.LDfilter.vcf \ -r \ -l 1 \ -m 0.01 \ -o GA0001 \ -b \ -B 2 \ -P tree_snphylo 3. PCA 分析 plink --vcf ../00.filter/all.LDfilter.vcf \ --pca 10 \ --out PCA_out \ --allow-extra-chr \ --set-missing-var-ids @:# Rscript ../script/draw_PCA.R PCA_out.eigenvec 1 2 ../data/sample.pop PCA_out_figure 4. 群体结构分析 # Step 0: vcf转bed格式 plink --vcf ../00.filter/all.LDfilter.vcf \ --make-bed \ --out all \ --allow-extra-chr \ --keep-allele-order \ --set-missing-var-ids @:# # Step 1: 生成Admixture运行脚本 seq 2 4 | awk '{print "admixture --cv -j2 all.bed "$1" 1>admix."$1".log 2>&amp;1"}' > admixture.sh # Step 2: 运行Admixture sh admixture.sh # 也可单独运行 admixture --cv -j2 all.bed 2 1>admix.2.log 2>&amp;1 admixture --cv -j2 all.bed 3 1>admix.3.log 2>&amp;1 admixture --cv -j2 all.bed 4 1>admix.4.log 2>&amp;1 # Step 3: 绘制结构图 mkdir result cp ./*.Q result/ Rscript ../script/draw_admixture.R result all.nosex structure 5. LD 衰减分析 # Step 1: 计算LD /pub/software/PopLDdecay/bin/PopLDdecay \ -InVCF ../data/all.vcf \ -SubPop ../data/pop.SC.table \ -MaxDist 500 \ -OutStat pop.SC.stat /pub/software/PopLDdecay/bin/PopLDdecay \ -InVCF ../data/all.vcf \ -SubPop ../data/pop.YZR.table \ -MaxDist 500 \ -OutStat pop.YZR.stat # Step 2: 绘制单群体LD衰减图 perl /pub/software/PopLDdecay/bin/Plot_OnePop.pl \ -inFile pop.SC.stat.gz \ -output pop.SC.ld perl /pub/software/PopLDdecay/bin/Plot_OnePop.pl \ -inFile pop.YZR.stat.gz \ -output pop.YZR.ld # Step 3: 绘制多群体LD衰减图 perl /pub/software/PopLDdecay/bin/Plot_MultiPop.pl \ -inList ld_stat.list \ -output ld_stat.multi 选择分析 1. π 和 ROD 分析 vcf=../../data/all.vcf window=20000 step=2000 # Step 1: 计算pi值 vcftools --vcf $vcf \ --window-pi $window \ --window-pi-step $step \ --keep ../../data/pop.SC.table \ --out ./Pi.pop1 vcftools --vcf $vcf \ --window-pi $window \ --window-pi-step $step \ --keep ../../data/pop.YZR.table \ --out ./Pi.pop2 # Step 2: 计算ROD pi1=Pi.pop1.windowed.pi pi2=Pi.pop2.windowed.pi perl ../../script/merge2pi_ROD.pl $pi1 $pi2 > Pi.ROD 2. Tajima’s D 分析 vcf=../../data/all.vcf window=20000 vcftools --vcf $vcf \ --TajimaD $window \ --keep ../../data/pop.SC.table \ --out TajimaD.pop1 vcftools --vcf $vcf \ --TajimaD $window \ --keep ../../data/pop.YZR.table \ --out TajimaD.pop2 3. Fst 分析 vcf=../../data/all.vcf window=20000 step=2000 vcftools --vcf $vcf \ --fst-window-size $window \ --fst-window-step $step \ --weir-fst-pop ../../data/pop.SC.table \ --weir-fst-pop ../../data/pop.YZR.table \ --out ./Fst.pop1.pop2 4. ROD + Fst 联合分析 fst=../03.Fst/Fst.pop1.pop2.windowed.weir.fst ROD=../01.pi_ROD/Pi.ROD gff=../../data/genome.gff # 提取显著位点 perl ../../script/top_Fst_ROD_S.pl $fst $ROD 0.05 0.05 Fst_ROD.table Fst_ROD.stat # 筛选top位点 awk '$NF=="top"' Fst_ROD.table > Fst_ROD.table.top # 提取基因注释 awk '$3=="gene"' $gff > gene.gff # 注释候选基因 bedtools intersect -wo -F 0.1 -a Fst_ROD.table.top -b gene.gff | \ awk -F "\t" '{print $7"\t"$10"\t"$11"\t"$13"\t"$15}' | \ sort -u > Fst_ROD.table.top.gene GWAS 分析 1. 基因型填充 beagle -Xmx4g -Djava.io.tmpdir=./TMP \ gt=../data/all.vcf \ out=all.impute \ impute=true \ window=10 \ nthreads=2 2. 标准 GWAS 分析 # Step 1: 准备VCF数据 plink --vcf ../data/all.vcf \ --maf 0.05 \ --geno 0.1 \ --recode12 \ --output-missing-genotype 0 \ --transpose \ --out snp_filter \ --set-missing-var-ids @:# \ --allow-extra-chr # 准备表型数据 perl ../script/sort_pheno.pl snp_filter.tfam ../data/trait.table > trait.sort.txt # Step 2: 计算亲缘关系矩阵 /pub/software/emmax/emmax-kin-intel64 -v -d 10 -o ./pop.kinship snp_filter # Step 3: 运行GWAS /pub/software/emmax/emmax-intel64 -v -d 10 \ -t snp_filter \ -p trait.sort.txt \ -k pop.kinship \ -o emmax.out 1> emmax.log 2>emmax.err # Step 4: 绘制曼哈顿图 paste snp_filter.map emmax.out.ps | \ awk 'BEGIN{print "SNP\tCHR\tBP\tP"}{if($2==$5){print $2"\t"$1"\t"$4"\t"$NF}}' \ > emmax.out.ps.manht_input Rscript ../script/manhattan.R emmax.out.ps.manht_input emmax.out.ps.manht_figure 3. GWAS-Q 分析（加入群体结构协变量） # 链接文件 ln -s ../01.GWAS/snp_filter.tped ln -s ../01.GWAS/snp_filter.tfam ln -s ../01.GWAS/snp_filter.nosex ln -s ../01.GWAS/snp_filter.map ln -s ../01.GWAS/trait.sort.txt ln -s ../../02.population_genetics/03.structure/all.3.Q # 准备Q矩阵 paste snp_filter.nosex all.3.Q | awk '{print $1" "$1" 1 "$3" "$4}' > pop.Qmatrix # 运行GWAS /pub/software/emmax/emmax-intel64 -v -d 10 \ -t snp_filter \ -p trait.sort.txt \ -k pop.kinship \ -c pop.Qmatrix \ -o emmax.out 1> emmax.log 2>emmax.err # 绘制曼哈顿图 paste snp_filter.map emmax.out.ps | \ awk 'BEGIN{print "SNP\tCHR\tBP\tP"}{if($2==$5){print $2"\t"$1"\t"$4"\t"$NF}}' \ > emmax.out.ps.manht_input Rscript ../script/manhattan.R emmax.out.ps.manht_input emmax.out.ps.manht_figure_Q 4. 真实数据 GWAS # Step 1: 准备数据 plink --vcf ../data_real/Sample215.M5M8H3.2allel.vcf \ --maf 0.05 \ --geno 0.1 \ --recode12 \ --output-missing-genotype 0 \ --transpose \ --out snp_filter \ --set-missing-var-ids @:# \ --allow-extra-chr perl ../script/sort_pheno.pl snp_filter.tfam ../data_real/trait.C16_0.table > trait.sort.txt # Step 2: 计算亲缘关系矩阵 /pub/software/emmax/emmax-kin-intel64 -v -d 10 -o ./pop.kinship snp_filter # Step 3: 运行GWAS /pub/software/emmax/emmax-intel64 -v -d 10 \ -t snp_filter \ -p trait.sort.txt \ -k pop.kinship \ -o emmax.out 1> emmax.log 2>emmax.err # Step 4: 绘制曼哈顿图 paste snp_filter.map emmax.out.ps | \ awk 'BEGIN{print "SNP\tCHR\tBP\tP"}{if($2==$5){print $2"\t"$1"\t"$4"\t"$NF}}' \ > emmax.out.ps.manht_input Rscript ../script/manhattan.R emmax.out.ps.manht_input emmax.out.ps.manht_figure_readData QTL-seq 分析 1. VCF 转换为 Table 格式 ref=&lt;reference.fasta> vcf=&lt;input.vcf> outfile=&lt;output.table> gatk VariantsToTable \ -R $ref \ -V $vcf \ -F CHROM -F POS -F REF -F ALT \ -GF AD -GF DP -GF GQ -GF PL \ -O $outfile 2. QTL-seq 分析（R 脚本） library(QTLseqr) library(ggplot2) # 设置参数 HighBulk &lt;- "SRR834931" # 高值混池名称 LowBulk &lt;- "SRR834927" # 低值混池名称 Chroms &lt;- paste0(rep("Chr", 12), 1:12) # 染色体列表 # ==================== 数据读取 ==================== df &lt;- importFromGATK( file = "../data/Yang_et_al_2013.table", highBulk = HighBulk, lowBulk = LowBulk, chromList = Chroms ) # ==================== 质量检查图 ==================== # 深度分布图 p1 &lt;- ggplot(data = df) + geom_histogram(aes(x = DP.HIGH + DP.LOW)) + xlim(0, 800) pdf(file = "SNP_depth.pdf") p1 dev.off() # REF等位基因频率分布 p2 &lt;- ggplot(data = df) + geom_histogram(aes(x = REF_FRQ)) pdf(file = "ref_allele_frequency.pdf") p2 dev.off() # 高值混池SNP-index分布 p3 &lt;- ggplot(data = df) + geom_histogram(aes(x = SNPindex.HIGH)) pdf(file = "SNPindex.HIGH.dis.pdf") p3 dev.off() # 低值混池SNP-index分布 p4 &lt;- ggplot(data = df) + geom_histogram(aes(x = SNPindex.LOW)) pdf(file = "SNPindex.LOW.dis.pdf") p4 dev.off() # ==================== SNP过滤 ==================== df_filt &lt;- filterSNPs( SNPset = df, refAlleleFreq = 0.20, # REF等位基因频率: 0.2~0.8 minTotalDepth = 100, # 最小总深度 maxTotalDepth = 400, # 最大总深度 minSampleDepth = 40, # 单样品最小深度 minGQ = 99, # 基因型质量阈值 verbose = TRUE ) # ==================== deltaSNPindex计算 ==================== df_filt &lt;- runQTLseqAnalysis( df_filt, windowSize = 1e6, # 窗口大小 popStruc = "F2", # 群体类型 bulkSize = c(385, 430), # 混池个体数 replications = 10000, # Bootstrap次数 intervals = c(95, 99) # 置信区间 ) # ==================== 结果可视化 ==================== # SNP沿染色体分布 p5 &lt;- plotQTLStats(SNPset = df_filt, var = "nSNPs") pdf(file = "SNP_filter.window.pdf", width = 20, height = 4) p5 dev.off() # deltaSNPindex沿染色体分布 p6 &lt;- plotQTLStats( SNPset = df_filt, var = "deltaSNP", plotIntervals = TRUE ) pdf(file = "deltaSNPindex.pdf", width = 20, height = 4) p6 dev.off() # ==================== 提取显著区域 ==================== QTL &lt;- getSigRegions( SNPset = df_filt, method = "QTLseq", interval = 95 ) write.table(QTL[[1]], "QTLseq_result.SigRegions.table", sep = "\t", quote = FALSE) # ==================== 导出完整结果 ==================== results99 &lt;- getQTLTable( SNPset = df_filt, method = "QTLseq", interval = 99, export = FALSE ) write.table( results99, file = "QTLseq_result_deltaSNPindex_CI99.table", sep = "\t", quote = FALSE ) 附录：分析流程图 plaintext
...</p></div><footer class=entry-footer><span title='2026-02-03 12:08:55 +0800 +0800'>February 3, 2026</span></footer><a class=entry-link aria-label="post link to 云南农业大学重测序项目教程" href=https://Tdxxxx-student.github.io/posts/%E4%BA%91%E5%8D%97%E5%86%9C%E4%B8%9A%E5%A4%A7%E5%AD%A6%E9%87%8D%E6%B5%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AI辅助教程</h2></header><div class=entry-content><p>这是基于我们刚才排查过的所有坑（环境报错、配置乱码、Git权限、部署冲突、文章不显示等），为你量身定制的**“避坑版”极简教程**。
这套方案采用 Hugo + GitHub Actions (自动部署) 方案。这是目前最稳定、最省心的方案，你只需要配置一次，以后写文章只需要“三行命令”。
🛠 第一步：环境与建站 假设你已经安装好了 Git 和 VS Code。
安装 Hugo (Windows 推荐) 打开 CMD 或 PowerShell：
winget install Hugo.Hugo.Extended (安装完后重启电脑，或者重启终端)
创建博客项目 找个盘符（比如 D 盘），右键打开 Git Bash：
# 1. 创建站点 hugo new site myblog cd myblog # 2. 初始化 Git git init # 3. 下载主题 (直接下载，避开 submodule 报错坑) git clone https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 ⚙️ 第二步：配置核心文件 (直接复制，不要改乱) 用 VS Code 打开 myblog 文件夹，找到 hugo.toml，全选删除，粘贴以下内容：
...</p></div><footer class=entry-footer><span title='2026-02-01 11:58:07 +0800 +0800'>February 1, 2026</span></footer><a class=entry-link aria-label="post link to AI辅助教程" href=https://Tdxxxx-student.github.io/posts/ai%E8%BE%85%E5%8A%A9%E6%95%99%E7%A8%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>部署文章</h2></header><div class=entry-content><p>使用Hugo 搭建博客并部署到 GitHub Pages April 4, 2025 本教程将从 0 开始，手把手教你在 Windows 系统中使用 Hugo 创建一个静态博客，并通过 GitHub Actions 自动部署到 GitHub Pages.
🧰 一、准备工作 ✅ 1. 安装 Git 下载并安装：https://git-scm.com 安装完成后，右键菜单应该出现 “Git Bash Here” 验证安装：
打开 power shell 检查 git 安装成功 git –version ✅ 2. 安装 Hugo（建议扩展版） 仅需在 power shell 输入
安装 winget install Hugo.Hugo.Extended
如需卸载 winget uninstall –name “Hugo (Extended)”
检查 Hugo是否安装成功 (重启终端 或 重启电脑) hugo version ✅ 3. 注册 GitHub 并创建仓库 Github 注册: https://github.com 创建一个与你用户名相同的仓库，比如: &lt;Github用户名>.github.io tu
...</p></div><footer class=entry-footer><span title='2026-02-01 00:00:00 +0000 UTC'>February 1, 2026</span></footer><a class=entry-link aria-label="post link to 部署文章" href=https://Tdxxxx-student.github.io/posts/hello-hugo/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://Tdxxxx-student.github.io/>我的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>