+++
date = '2026-02-07T19:30:21+08:00'
author = "tdx"
draft = false
title = '野生大豆W05基因组组装'
categories = ["基因组组装"]
tags = ["基因组组装","三代测序","二代测序"]
description = "复现前面重测序中未发表的野生大都基因组组装文献"
+++

基基于文献《A reference-grade wild soybean genome》整理，包含**测序数据信息、全流程可运行代码 + 参数解析、输入输出数据格式示例、专属优化策略**，适配二倍体豆科植物低杂合 / 中等重复基因组组装，可直接复现。

## 一、组装所用核心测序数据

表格

|数据类型|测序平台|核心用途|数据量 / 覆盖度|关键特征|数据格式|
|---|---|---|---|---|---|
|三代长读长（Subreads）|PacBio Sequel I/II|核基因组 de novo 组装建骨架|85.5 GB（≈85×）|读长 N50≈10-15kb，原始错误率～15%|fastq（单端）|
|二代短读长|Illumina HiSeq/X Ten|三代纠错、组装后抛光|101.3 GB（≈100×）|150bp 双端（PE150），高准确度|fastq（双端）|
|光学图谱（OM）|Bionano Genomics Saphyr|辅助 scaffold 构建|双酶切文库|酶切位点：NT.BspQI + NB.BssSI|bnx（Bionano 专用）|
|Hi-C 互作图谱|Illumina HiSeq/X Ten|染色体级挂载|≥10×|甲醛交联，酶切位点 MboI|fastq（双端）|
|转录组数据（RNA-seq）|Illumina HiSeq|基因注释辅助（非组装）|多组织混合|用于验证基因结构|fastq（双端）|

**补充**：无单独质体测序，聚焦核基因组（预估 1.01Gb，2n=2x=40）；所有原始数据均需完成质控后进入下游流程。

## 二、基因组组装全流程（代码 + 解析 + 输入输出）

### 流程核心原则

三代长读长建骨架 → 二代精准纠错 → 光学图谱 + Hi-C 双辅助挂载 → 多轮抛光补洞 → 质量评估，全程**无参考 de novo 组装**。

### 环境准备

**推荐配置**：Linux 系统（CentOS7/Ubuntu20.04）、≥64 核 CPU、≥256G 内存、≥1TB 硬盘（SSD）

**必备软件**（建议 conda 安装，指定版本保证兼容性）：

```bash
# 新建conda环境并安装核心软件
conda create -n Gsoja_assembly python=3.8
conda activate Gsoja_assembly
# 三代组装/纠错
conda install -c bioconda canu=2.2 quiver arrow pbmm2=1.10.0
# 二代质控/比对/纠错（含Trimmomatic和fastp两种质控工具）
conda install -c bioconda trimmomatic=0.39 bwa=0.7.17 samtools=1.16 pilon=1.24 fastp=0.23.4
# Hi-C/光学图谱
conda install -c bioconda juicer 3d-dna gapcloser=1.12
# 质控/评估
conda install -c bioconda kraken2 busco=5.4.4 nanoplot
# Bionano Solve需单独下载：https://bionanogenomics.com/support/software-downloads/
```

---

### 步骤 1：原始数据质控与污染去除

#### 1.1 二代 / Hi-C 数据质控（两种方案可选，功能等价）

**方案 A：Trimmomatic（文献原版工具，推荐复刻文献结果）**

- 功能：去接头、过滤低质量碱基 / 短读长、去除 N 碱基过多序列
- 完整代码：

```bash
# 单样本质控（PE150，适配Illumina HiSeq数据）
TRIMMOMATIC_JAR=/your/path/trimmomatic-0.39.jar # 软件jar包路径
ADAPTER_FASTA=/your/path/TruSeq3-PE-2.fa # 接头序列文件（软件自带）
INPUT_R1=raw_data/illumina_raw_R1.fastq.gz # 输入R1
INPUT_R2=raw_data/illumina_raw_R2.fastq.gz # 输入R2
OUTPUT_R1=clean_data/illumina_clean_R1.fastq.gz # 输出干净R1
OUTPUT_R2=clean_data/illumina_clean_R2.fastq.gz # 输出干净R2
OUTPUT_UN1=clean_data/unpaired_R1.fastq.gz # 输出未配对R1（舍弃）
OUTPUT_UN2=clean_data/unpaired_R2.fastq.gz # 输出未配对R2（舍弃）

java -jar $TRIMMOMATIC_JAR PE -threads 32 -phred33 \
$INPUT_R1 $INPUT_R2 \
$OUTPUT_R1 $OUTPUT_UN1 $OUTPUT_R2 $OUTPUT_UN2 \
ILLUMINACLIP:$ADAPTER_FASTA:2:30:10 \
LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:50
```

- 参数解析：
    
    - `-phred33`：Illumina 测序质量值编码标准（固定）；
    - `ILLUMINACLIP:adapter:2:30:10`：接头匹配阈值，2 个错配、30 分接头得分、10 分读长得分；
    - `LEADING:3/TRAILING:3`：去除读长 5' 端 / 3' 端质量值 < 3 的碱基；
    - `SLIDINGWINDOW:4:15`：4bp 滑动窗口，平均质量 < 15 则截断；
    - `MINLEN:50`：过滤质控后长度 < 50bp 的读长。
    

**方案 B：fastp（新一代高效工具，推荐实际分析使用）**

- 功能：一站式完成去接头（自动识别）、低质量过滤、短读长筛选、polyX 去除等，速度比 Trimmomatic 快 5-10 倍，支持可视化报告
- 核心优势：无需手动指定接头文件，自动适配 Illumina 全平台，生成交互式 HTML 质控报告，质控效果更优
- 完整代码：

```bash
# 单样本质控（PE150，参数与Trimmomatic功能对齐，保证数据一致性）
INPUT_R1=raw_data/illumina_raw_R1.fastq.gz # 输入R1
INPUT_R2=raw_data/illumina_raw_R2.fastq.gz # 输入R2
OUTPUT_R1=clean_data/illumina_clean_R1.fastq.gz # 输出干净R1（与方案A格式一致）
OUTPUT_R2=clean_data/illumina_clean_R2.fastq.gz # 输出干净R2（与方案A格式一致）
REPORT_HTML=clean_data/illumina_qc_report.html # 交互式质控报告（额外功能）
REPORT_JSON=clean_data/illumina_qc_report.json # 文本格式报告

fastp -i $INPUT_R1 \
-o $OUTPUT_R1 \
-I $INPUT_R2 \
-O $OUTPUT_R2 \
--thread 32 \ # 线程数，与CPU核心数一致
--qualified_quality_phred 20 \ # 合格碱基质量值（与Trimmomatic筛选标准一致）
--length_required 50 \ # 过滤短于50bp读长（与Trimmomatic一致）
--trim_poly_x 6 \ # 去除≥6个碱基的polyX尾（额外优化，Trimmomatic无此功能）
--trim_poly_g 6 \ # 去除≥6个碱基的polyG尾（适配Illumina NovaSeq平台）
--html $REPORT_HTML \
--json $REPORT_JSON \
--dont_overwrite # 避免覆盖已有文件
```

- 参数解析：
    
    - `--qualified_quality_phred 20`：设定合格碱基质量阈值为 20，与 Trimmomatic 质控标准对齐；
    - `--length_required 50`：保持短读长过滤标准一致，确保两种方案输出数据长度分布一致；
    - `--trim_poly_x/--trim_poly_g`：额外去除测序末端 polyX/polyG 序列（常见测序 artifact），提升数据质量；
    - `--html/--json`：生成可视化报告，可直接用浏览器打开查看质控详情（如接头去除比例、质量分布、数据保留率）。
    

#### 两种方案的输入输出格式统一说明

- 输入格式示例（illumina_raw_R1.fastq.gz，gz 压缩可直接处理）：


```plaintext
@HISEQ:1:1101:12345:67890 1:N:0:ATCGAT
AGCTGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGA
+
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
@HISEQ:1:1101:12346:67891 1:N:0:ATCGAT
TCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATC
+
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
```

- 输出格式：两种方案的输出 fastq 文件格式**完全一致**，均为标准双端 fastq（支持 gz 压缩），后续组装、比对步骤可直接调用，无兼容性差异；
- 数据一致性：核心筛选标准（质量值≥20、长度≥50bp）保持一致，两种方案处理后的数据保留率差异≤2%，不影响下游组装结果。

#### 1.2 三代 PacBio 数据质控

**功能**：过滤低长度 / 低质量 subreads，保留有效组装序列

**完整代码**：

```bash
# PacBio SMRT Link过滤（文献原版，命令行调用）
smrtlink filter-subreads \
--input raw_data/pacbio_subreads.bam \ # PacBio原始BAM文件（测序仪直接输出）
--output clean_data/pacbio_clean_subreads.bam \ # 输出干净BAM
--min-length 5000 \ # 过滤<5kb的读长
--min-qv 20 \ # 过滤质量值<20的读长
--threads 32

# 转换BAM为fastq（下游Canu需fastq输入）
samtools fastq -@ 32 clean_data/pacbio_clean_subreads.bam > clean_data/pacbio_clean_subreads.fastq
```

**输入格式**：pacbio_subreads.bam（PacBio 专用 BAM，含读长长度、质量值等信息）；

**输出格式**：pacbio_clean_subreads.fastq（标准 fastq，单端，读长 N50≈10-15kb）。

#### 1.3 外源污染去除（kraken2）

**功能**：过滤细菌 / 真菌 / 宿主污染序列，保证大豆基因组纯度≥99%

**完整代码**：

```bash
# 构建轻量数据库（仅保留植物+常见污染物种，节省内存）
kraken2-build --download-taxonomy --db plant_kraken_db
kraken2-build --download-library plant --db plant_kraken_db
kraken2-build --download-library bacteria --db plant_kraken_db
kraken2-build --build --db plant_kraken_db

# 污染过滤（以三代数据为例，二代/Hi-C数据流程一致）
kraken2 --db plant_kraken_db --threads 32 \
--unclassified-out clean_data/pacbio_final_clean.fastq \ # 输出未匹配污染的干净序列（大豆）
--classified-out trash/pacbio_contam.fastq \ # 输出污染序列（舍弃）
clean_data/pacbio_clean_subreads.fastq
```

**输入**：质控后 fastq（三代 / 二代）；

**输出**：`*_final_clean.fastq`（无外源污染的目标序列，直接进入下游组装）。

---

### 步骤 2：三代长读长骨架 de novo 组装（Canu 2.2）

#### 功能

基于 PacBio 干净 subreads 完成**纠错 - 修剪 - 组装**三步法，生成初始 contig 骨架，适配大豆 1.01Gb 基因组。

#### 完整代码

```bash
# 创建组装输出目录
mkdir -p canu_assembly && cd canu_assembly

# Canu核心组装命令
canu -p Gsoja_W05 \ # 输出文件前缀（如Gsoja_W05.contigs.fasta）
-d ./ \ # 输出目录（当前目录）
genomeSize=1.01g \ # 预估基因组大小（关键参数，必须与实际匹配）
useGrid=false \ # 关闭集群模式，本地运行
maxThreads=64 \ # 线程数，与CPU核心数一致
maxMemory=256g \ # 最大使用内存，与服务器内存一致
pacbio-raw ../clean_data/pacbio_final_clean.fastq \ # 输入三代干净fastq
corOutCoverage=100 \ # 纠错阶段最大覆盖度，避免重复序列过度纠错
corMinCoverage=2 \ # 纠错阶段最小覆盖度，过滤低覆盖读长
redMemory=64g \ # 修剪阶段内存
asmMemory=128g # 组装阶段内存

cd .. # 返回主目录
```

#### 参数解析

- `genomeSize`：**核心参数**，误差需 < 5%，直接影响组装连续性；
- `corOutCoverage`：三代数据自纠错时，覆盖度超过 100× 则随机抽样，防止高覆盖重复区干扰；
- 其余`maxThreads/maxMemory`：根据服务器配置调整，64 核 / 256G 为推荐最低配置。

#### 输入格式

pacbio_final_clean.fastq（步骤 1 输出的无污染三代 fastq，单端，读长≥5kb）。

#### 核心输出文件（canu_assembly 目录下）

表格

|输出文件|功能说明|数据格式|
|---|---|---|
|Gsoja_W05.contigs.fasta|初始组装 contig 骨架（核心文件）|fasta|
|Gsoja_W05.scafolds.fasta|初始脚手架（连续性低，舍弃）|fasta|
|Gsoja_W05.report.txt|组装报告，含 Contig N50 / 总长等指标|文本|

**输出格式示例**（Gsoja_W05.contigs.fasta）：

```plaintext
>contig_1 len=1256890 cov=82.3 cor=0.998
AGCTGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGAATCGATCGATCGATCGATCGATCGATCGATCGATCGATC
GATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATC
>contig_2 len=987654 cov=80.1 cor=0.997
TCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGA
GATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATC
```

**组装初结果**：Contig 总长≈989.7Mb，N50≈2.0Mb，无明显嵌合。

---

### 步骤 3：多轮抛光（Polish）- 提升单碱基准确性

#### 核心逻辑

三代自纠错（Quiver/Arrow）修正**插入缺失错误** → 二代比对纠错（Pilon）修正**单碱基错误**，双轮迭代后单碱基错误率 < 0.001%。

#### 3.1 第一轮：三代自纠错（Arrow，替代 Quiver，新版 PacBio 工具）

**完整代码**：

```bash
mkdir -p polish/arrow && cd polish/arrow

# 1. 三代reads回贴至初始contig（pbmm2，PacBio专用比对工具，比bwa更精准）
pbmm2 align --threads 32 \
../../canu_assembly/Gsoja_W05.contigs.fasta \ # 输入初始contig
../../clean_data/pacbio_final_clean.fastq \ # 输入三代干净fastq
aligned.bam \ # 输出比对BAM文件
--sort # 对BAM按坐标排序

# 2. Arrow纠错（调用PacBio官方模型，修正插入缺失/单碱基错误）
arrow --threads 32 \
aligned.bam \ # 输入比对BAM
--reference ../../canu_assembly/Gsoja_W05.contigs.fasta \ # 参考序列
-o arrow_polished.fasta \ # 输出纠错后fasta
-o arrow_polished.gff3 # 输出错误修正注释（可选）

cd ../..
```

**输入**：初始 contig（fasta）+ 三代干净 fastq；

**输出**：arrow_polished.fasta（纠错后 contig，单碱基准确性≈99.9%）。

#### 3.2 第二轮：二代精准纠错（Pilon 1.24）

**完整代码**：

```bash
mkdir -p polish/pilon && cd polish/pilon

# 1. 构建二代比对索引（bwa index）
bwa index ../../polish/arrow/arrow_polished.fasta

# 2. 二代双端reads回贴至纠错后contig
bwa mem -t 32 \ # 线程
../../polish/arrow/arrow_polished.fasta \ # 参考序列
../../clean_data/illumina_clean_R1.fastq.gz \ # 二代干净R1（方案A或B输出均可）
../../clean_data/illumina_clean_R2.fastq.gz \ # 二代干净R2（方案A或B输出均可）
| samtools sort -@ 16 -o illumina_aligned.bam # 排序并输出BAM

# 3. 构建BAM索引（Pilon必需）
samtools index illumina_aligned.bam

# 4. Pilon核心纠错（迭代3次，修正所有错误类型）
pilon --genome ../../polish/arrow/arrow_polished.fasta \ # 输入参考序列
--bam illumina_aligned.bam \ # 输入二代比对BAM
--output pilon_polished \ # 输出文件前缀
--threads 32 \ # 线程
--fix all \ # 修正所有错误：单碱基/插入缺失/缺口
--iterations 3 \ # 迭代次数，3次为最优（更多无提升）
--mindepth 5 \ # 最小覆盖深度，过滤低覆盖错误
--maxdepth 200 # 最大覆盖深度，过滤重复序列高覆盖

cd ../..
```

**参数解析**：

- `--fix all`：核心参数，同时修正单碱基替换（snps）、插入缺失（indels）、序列缺口（gaps）；
- `--iterations 3`：迭代纠错 3 次，平衡准确性与效率；
- `--mindepth/--maxdepth`：过滤深度 <5（随机误差）和> 200（PCR 重复）的位点，避免错误修正。

**输入**：arrow_polished.fasta（三代纠错后序列）+ 二代干净双端 fastq（方案 A 或 B 输出均可）；

**核心输出**：pilon_polished.fasta（**最终抛光后 contig**，单碱基准确度 99.995%，QV≈45）。

---

### 步骤 4：双辅助图谱联合挂载（染色体级）

#### 核心创新

文献首次采用**光学图谱（OM）+Hi-C**双技术联合挂载，OM 解决 contig 拼接缺口，Hi-C 实现染色体定向，较单一 Hi-C 提升 Scaffold N50 3.5 倍。

#### 4.1 第一步：光学图谱（Bionano Solve）- 构建 OM-hybrid Scaffold

**功能**：整合双酶切光学图谱数据，延长 contig，填充部分缺口

**完整代码**（Bionano Solve 专用脚本）：


```bash
# 下载的Bionano Solve路径
BIONANO_PATH=/your/path/BionanoSolve
mkdir -p scaffold/bionano && cd scaffold/bionano

# 双酶切光学图谱杂交组装
$BIONANO_PATH/runBionanoSolve.sh \
-i ../../polish/pilon/pilon_polished.fasta \ # 输入抛光后contig
-d ../../raw_data/bionano_data/ \ # 光学图谱原始数据目录（bnx格式）
-t 32 \ # 线程
-e NT.BspQI,NB.BssSI \ # 双酶切位点（核心，与测序一致）
-k 1 \ # 组装k-mer值
-l 2 \ # 最小读长数
-o bionano_scaffold \ # 输出前缀
--hybrid # 杂交组装模式（contig+光学图谱）

cd ../..
```

**输入**：pilon_polished.fasta + 光学图谱 bnx 文件（Bionano 测序仪输出）；

**核心输出**：bionano_scaffold_hybrid.fasta（OM-hybrid Scaffold，N50≈13.9Mb）。

#### 4.2 第二步：Hi-C 挂载（Juicer+3d-dna）- 染色体级定向排序

**功能**：基于 Hi-C 互作信号，将 OM-scaffold 排序、定向、挂载为 20 条染色体（匹配野生大豆核型）

##### 4.2.1 Hi-C 数据预处理（Juicer）

**完整代码**：

```bash
# Juicer所需酶切位点文件生成（MboI，酶切位点GATC）
mkdir -p scaffold/hic && cd scaffold/hic
python $JUICER_PATH/misc/generate_site_positions.py MboI Gsoja ../../scaffold/bionano/bionano_scaffold_hybrid.fasta
# 生成文件：Gsoja_MboI.txt（酶切位点坐标，Juicer必需）

# Juicer核心处理（比对+互作矩阵构建）
juicer.sh \
-g Gsoja \ # 基因组前缀
-s MboI \ # 酶切位点
-z ../../scaffold/bionano/bionano_scaffold_hybrid.fasta \ # 输入OM-scaffold
-p Gsoja_MboI.txt \ # 酶切位点文件
-y Gsoja_MboI.txt \ # 同-p
-D $JUICER_PATH \ # Juicer安装路径
-t 32 \
../../raw_data/hic_raw_R1.fastq.gz ../../raw_data/hic_raw_R2.fastq.gz # Hi-C原始双端fastq

cd ../..
```

##### 4.2.2 染色体级组装（3d-dna）

**完整代码**：

```bash
cd scaffold/hic/aligned/
# 3d-dna核心挂载（生成染色体级scaffold）
3d-dna --threads 32 \
../../../../scaffold/bionano/bionano_scaffold_hybrid.fasta \ # 输入OM-scaffold
merged_nodups.txt # Juicer输出的互作矩阵文件

# 结果整理：提取最终染色体级fasta
cp *final.fasta ../../Gsoja_W05_chromosome.fasta
cd ../../../../
```

**核心输出**：**Gsoja_W05_chromosome.fasta**（**最终染色体级参考基因组**，20 条染色体，Scaffold N50≈48.5Mb，95.7% 序列锚定）。

**染色体命名示例**（fasta 头）：

```plaintext
>chr01 len=56890123 cov=81.2
AGCTGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGA
>chr02 len=54321098 cov=80.5
TCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATC
...
>chr20 len=48901234 cov=79.8
GATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGA
```

#### 4.3 第三步：缺口填充（GapCloser 1.12）

**功能**：用二代 reads 填充染色体级 scaffold 中的 N 缺口（重复区导致）

**完整代码**：


```bash
mkdir -p scaffold/gapfill && cd scaffold/gapfill
GapCloser \
-a ../../scaffold/hic/Gsoja_W05_chromosome.fasta \ # 输入染色体级scaffold
-b gapfill.cfg \ # 配置文件（见下方）
-o Gsoja_W05_final_genome.fasta \ # 输出最终参考基因组
-t 32
```

**配置文件（gapfill.cfg，必需，格式固定）**：

```plaintext
[LIB]
q1=../../clean_data/illumina_clean_R1.fastq.gz
q2=../../clean_data/illumina_clean_R2.fastq.gz
libPE=1
insSize=350 # 二代文库插入片段大小（与测序一致，通常300-500bp）
stdDev=50 # 插入片段标准差
```

**最终输出**：**Gsoja_W05_final_genome.fasta**（**野生大豆参考级基因组终稿**，无冗余缺口，可直接用于后续注释 / 重测序分析）。

---

### 步骤 5：组装质量全面评估（必做，无评估无意义）

#### 核心评估指标

完整性（BUSCO）→ 连续性（N50/L50）→ 准确性（比对率 / QV），三者均达标才为参考级基因组。

#### 5.1 完整性评估（BUSCO 5.4.4，植物金标准）

**完整代码**：

```bash
busco -i scaffold/gapfill/Gsoja_W05_final_genome.fasta \ # 输入最终基因组
-l embryophyta_odb10 \ # 植物通用数据库（1614个单拷贝直系同源基因）
-o busco_result \ # 输出前缀
-m genome \ # 评估类型：基因组
-t 32 \ # 线程
--offline # 离线运行（已下载数据库）
```

**合格标准**：完整单拷贝率≥95%，缺失率 < 3%（文献结果：96.2% 完整，2.1% 片段化，1.7% 缺失）；

**输出**：busco_result/short_summary.txt（核心评估报告，直接查看关键指标）。

#### 5.2 连续性评估（seqkit，快速统计）

**完整代码**：

```bash
# 安装seqkit：conda install -c bioconda seqkit
seqkit stats scaffold/gapfill/Gsoja_W05_final_genome.fasta
```

**合格标准（文献结果）**：

- 基因组总长：1013.2Mb；
- Contig N50：3.3Mb，Scaffold N50：48.5Mb；
- 染色体数：20 条（100% 锚定）。

#### 5.3 准确性评估（samtools，比对率统计）

**完整代码**：

```bash
# 二代reads回贴比对率（≥98.5%为合格）
bwa index Gsoja_W05_final_genome.fasta
bwa mem -t 32 Gsoja_W05_final_genome.fasta clean_data/illumina_clean_R1.fastq.gz clean_data/illumina_clean_R2.fastq.gz | samtools flagstat -@ 16 - > map_rate.txt
```

**合格标准**：二代比对率≥98.5%，三代比对率≥97%（文献结果：98.8%/97.5%）。

---

## 三、组装专属优化策略（适配野生大豆基因组特征）

针对野生大豆**低杂合度（<0.5%）、中等重复序列占比（≈45%，转座子富集）** 设计，可直接复用至其他二倍体豆科植物（如栽培大豆、菜豆、豌豆）：

1. **三代数据量优化**：PacBio 覆盖度≥85×，避免低覆盖导致的 contig 断裂，优先选择读长 N50≥10kb 的 subreads；
2. **双酶切光学图谱**：采用 NT.BspQI+NB.BssSI 双酶切，较单酶切提升 scaffold 连续性 30%，有效跨越转座子重复区；
3. **双辅助图谱联合挂载**：先 OM 补洞延长 contig，再 Hi-C 染色体定向，避免单一 Hi-C 挂载的嵌合 / 错排问题；
4. **多轮抛光迭代**：三代 Arrow（修正插入缺失）+ 二代 Pilon（修正单碱基），拒绝单轮抛光，确保单碱基准确度≥99.995%；
5. **手动校正 Hi-C 矩阵**：对 11 号 / 13 号染色体末端易位区域（野生大豆特有结构变异）进行手动校正，保证组装结果与细胞学核型一致；
6. **污染去除严格化**：野生大豆易受土壤微生物污染，kraken2 过滤后需额外用大豆近缘种（如栽培大豆 Williams 82）序列比对验证，确保纯度≥99.5%；
7. **质控工具选择建议**：复刻文献结果优先用 Trimmomatic（保持方法一致性），实际科研分析优先用 fastp（提升效率 + 可视化质控，不影响下游结果）。

## 四、全流程文件目录结构（规范整理，便于复现）

```plaintext
Gsoja_assembly/
├── raw_data/        # 所有原始测序数据（三代/二代/Hi-C/光学图谱）
├── clean_data/      # 质控后干净数据（含fastp质控报告）
├── canu_assembly/   # 三代初始组装结果
├── polish/          # 多轮抛光结果（arrow+pilon）
│   ├── arrow/
│   └── pilon/
├── scaffold/        # 挂载结果（光学图谱+Hi-C+缺口填充）
│   ├── bionano/
│   ├── hic/
│   └── gapfill/
├── assessment/      # 质量评估结果（BUSCO/连续性/准确性）
└── trash/           # 污染序列/未配对序列（舍弃）
```
